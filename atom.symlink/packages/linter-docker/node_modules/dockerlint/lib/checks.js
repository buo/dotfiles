// Generated by CoffeeScript 1.9.0
(function() {
  var os, path, utils;

  os = require('os');

  path = require('path');

  utils = require(__dirname + "/utils");

  exports.all = ['from_first', 'no_empty_tag', 'no_empty_digest', 'json_array_format', 'json_array_even_quotes', 'add', 'multiple_entries', 'sudo', 'absolute_workdir', 'onbuild_copyadd', 'onbuild_disallowed', 'label_no_empty_value'];

  Array.prototype.filter = function(func) {
    var x, _i, _len, _results;
    _results = [];
    for (_i = 0, _len = this.length; _i < _len; _i++) {
      x = this[_i];
      if (func(x)) {
        _results.push(x);
      }
    }
    return _results;
  };

  exports.getAll = function(instruction, rules) {
    return rules.filter(function(r) {
      return r.instruction === instruction;
    });
  };

  exports.getAllExcept = function(instruction, rules) {
    return rules.filter(function(r) {
      return r.instruction !== instruction;
    });
  };

  exports.from_first = function(rules) {
    var first, non_comments;
    non_comments = this.getAllExcept('comment', rules);
    first = non_comments[0];
    if (first.instruction !== 'FROM') {
      utils.log('ERROR', "First instruction must be 'FROM', is: " + first.instruction);
      return 'failed';
    }
    return 'ok';
  };

  exports.no_empty_tag = function(rules) {
    var from, image, rule, tag, _i, _len, _ref;
    from = this.getAll('FROM', rules);
    for (_i = 0, _len = from.length; _i < _len; _i++) {
      rule = from[_i];
      if (rule["arguments"][0].match(/:/)) {
        _ref = rule["arguments"][0].split(':'), image = _ref[0], tag = _ref[1];
        if (!utils.notEmpty(tag)) {
          utils.log('ERROR', "Tag must not be empty for \"" + image + "\" on line " + rule.line);
          return 'failed';
        }
      }
    }
    return 'ok';
  };

  exports.no_empty_digest = function(rules) {
    var digest, from, image, rule, _i, _len, _ref;
    from = this.getAll('FROM', rules);
    for (_i = 0, _len = from.length; _i < _len; _i++) {
      rule = from[_i];
      if (rule["arguments"][0].match(/@/)) {
        _ref = rule["arguments"][0].split('@'), image = _ref[0], digest = _ref[1];
        if (!utils.notEmpty(digest)) {
          utils.log('ERROR', "Digest must not be empty for \"" + image + "\" on line " + rule.line);
          return 'failed';
        }
      }
    }
    return 'ok';
  };

  exports.json_array_format = function(rules) {
    var argument, i, r, rule, _i, _j, _k, _len, _len1, _len2, _ref, _ref1;
    _ref = ['CMD', 'ENTRYPOINT', 'RUN', 'VOLUME'];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      i = _ref[_i];
      rule = this.getAll(i, rules);
      for (_j = 0, _len1 = rule.length; _j < _len1; _j++) {
        r = rule[_j];
        _ref1 = r["arguments"];
        for (_k = 0, _len2 = _ref1.length; _k < _len2; _k++) {
          argument = _ref1[_k];
          if (argument.match(/\[.*'.*\]/)) {
            utils.log('ERROR', "Arguments to " + i + " in exec for must not contain single quotes on line " + r.line);
            return 'failed';
          }
        }
      }
    }
    return 'ok';
  };

  exports.json_array_even_quotes = function(rules) {
    var i, quotes, r, rule, _i, _j, _len, _len1, _ref;
    _ref = ['CMD', 'ENTRYPOINT', 'RUN', 'VOLUME'];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      i = _ref[_i];
      rule = this.getAll(i, rules);
      for (_j = 0, _len1 = rule.length; _j < _len1; _j++) {
        r = rule[_j];
        quotes = r["arguments"].join(' ').split('"');
        if (!(quotes.length % 2)) {
          utils.log('ERROR', "Odd number of double quotes on line " + r.line);
          return 'failed';
        }
      }
    }
    return 'ok';
  };

  exports.add = function(rules) {
    var add, lines, rule, _i, _len;
    add = this.getAll('ADD', rules);
    if (add.length > 0) {
      lines = [];
      for (_i = 0, _len = add.length; _i < _len; _i++) {
        rule = add[_i];
        if (!rule["arguments"][0].match(/\.(tar|gz|bz2|xz)/)) {
          lines.push(rule.line);
        }
      }
      if (lines.length > 0) {
        utils.log('WARN', "ADD instruction used instead of COPY on line " + (lines.join(', ')));
        return 'failed';
      }
    }
    return 'ok';
  };

  exports.multiple_entries = function(rules) {
    var e, rule, _i, _len, _ref;
    _ref = ['CMD', 'ENTRYPOINT'];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      e = _ref[_i];
      rule = this.getAll(e, rules);
      if (rule.length > 1) {
        utils.log('ERROR', "Multiple " + e + " instructions found, only line " + rule[rule.length - 1].line + " will take effect");
        return 'failed';
      }
    }
    return 'ok';
  };

  exports.sudo = function(rules) {
    var argument, rule, run, _i, _j, _len, _len1, _ref;
    run = this.getAll('RUN', rules);
    for (_i = 0, _len = run.length; _i < _len; _i++) {
      rule = run[_i];
      _ref = rule["arguments"];
      for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
        argument = _ref[_j];
        if (argument.match(/sudo/)) {
          utils.log('WARN', "sudo(8) usage found on line " + rule.line + " which is discouraged");
          return 'failed';
        }
      }
    }
    return 'ok';
  };

  exports.absolute_workdir = function(rules) {
    var absolute, rule, workdir, _i, _len;
    workdir = this.getAll('WORKDIR', rules);
    for (_i = 0, _len = workdir.length; _i < _len; _i++) {
      rule = workdir[_i];
      if (os.platform() === 'win32') {
        absolute = path.isAbsolute(rule["arguments"][0]);
      } else {
        absolute = path.normalize(rule["arguments"][0]) === path.resolve(rule["arguments"][0]);
      }
      if (!absolute) {
        utils.log('ERROR', "WORKDIR path " + rule["arguments"] + " must be absolute on line " + rule.line);
        return 'failed';
      }
    }
    return 'ok';
  };

  exports.onbuild_copyadd = function(rules) {
    var argument, onbuild, rule, _i, _j, _len, _len1, _ref;
    onbuild = this.getAll('ONBUILD', rules);
    for (_i = 0, _len = onbuild.length; _i < _len; _i++) {
      rule = onbuild[_i];
      _ref = rule["arguments"];
      for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
        argument = _ref[_j];
        if (argument.match(/ADD|COPY/)) {
          utils.log('WARN', "It is advised not to use ADD or COPY for ONBUILD on line " + rule.line);
          return 'failed';
        }
      }
    }
    return 'ok';
  };

  exports.onbuild_disallowed = function(rules) {
    var argument, chained_instruction, onbuild, rule, _i, _j, _len, _len1, _ref;
    onbuild = this.getAll('ONBUILD', rules);
    for (_i = 0, _len = onbuild.length; _i < _len; _i++) {
      rule = onbuild[_i];
      _ref = rule["arguments"];
      for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
        argument = _ref[_j];
        chained_instruction = argument.split(' ')[0];
        if (chained_instruction.match(/ONBUILD|FROM|MAINTAINER/)) {
          utils.log('ERROR', "ONBUILD may not be chained with " + chained_instruction + " on line " + rule.line);
          return 'failed';
        }
      }
    }
    return 'ok';
  };

  exports.label_no_empty_value = function(rules) {
    var argument, label, pair, rule, _i, _j, _k, _len, _len1, _len2, _ref, _ref1;
    label = this.getAll('LABEL', rules);
    for (_i = 0, _len = label.length; _i < _len; _i++) {
      rule = label[_i];
      _ref = rule["arguments"];
      for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
        argument = _ref[_j];
        _ref1 = argument.split(' ');
        for (_k = 0, _len2 = _ref1.length; _k < _len2; _k++) {
          pair = _ref1[_k];
          if (pair.slice(-1) === '=') {
            utils.log('ERROR', "LABEL requires value for line " + rule.line);
            return 'failed';
          }
        }
      }
    }
    return 'ok';
  };

}).call(this);

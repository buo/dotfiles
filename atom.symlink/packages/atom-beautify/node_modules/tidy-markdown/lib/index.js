// Generated by CoffeeScript 1.10.0
(function() {
  var delimitCode, fixHeaders, fm, formatTable, indent, longestStringInArray, marked, pad, preprocessAST, ref, stringRepeat, tidyInlineMarkdown, yaml;

  fm = require('front-matter');

  indent = require('indent');

  marked = require('marked');

  pad = require('pad');

  yaml = require('js-yaml');

  ref = require('./utils'), stringRepeat = ref.stringRepeat, longestStringInArray = ref.longestStringInArray, delimitCode = ref.delimitCode;

  preprocessAST = require('./preprocess');

  tidyInlineMarkdown = require('./tidy-inline-markdown');


  /**
   * Some people accidently skip levels in their headers (like jumping from h1 to
   * h3), which screws up things like tables of contents. This function fixes
   * that.
  
   * The algorithm assumes that relations between nearby headers are correct and
   * will try to preserve them. For example, "h1, h3, h3" becomes "h1, h2, h2"
   * rather than "h1, h2, h3".
   */

  fixHeaders = function(ast, ensureFirstHeaderIsH1) {
    var e, gap, i, lastHeaderDepth, parentDepth, ref1, rootDepth;
    i = 0;
    lastHeaderDepth = 0;
    if (!ensureFirstHeaderIsH1) {
      e = 0;
      while (e < ast.length) {
        if (ast[e].type !== 'heading') {
          e++;
        } else {
          lastHeaderDepth = ast[e].depth - 1;
          break;
        }
      }
    }
    rootDepth = lastHeaderDepth + 1;
    while (i < ast.length) {
      if (ast[i].type !== 'heading') {

      } else if ((rootDepth <= (ref1 = ast[i].depth) && ref1 <= lastHeaderDepth + 1)) {
        lastHeaderDepth = ast[i].depth;
      } else {
        e = i;
        if (ast[i].depth <= rootDepth) {
          gap = ast[i].depth - rootDepth;
        } else {
          gap = ast[i].depth - (lastHeaderDepth + 1);
        }
        parentDepth = ast[i].depth;
        while (e < ast.length) {
          if (ast[e].type !== 'heading') {

          } else if (ast[e].depth >= parentDepth) {
            ast[e].depth -= gap;
          } else {
            break;
          }
          e++;
        }
        continue;
      }
      i++;
    }
    return ast;
  };

  formatTable = function(token) {
    var alignment, col, colWidth, i, j, k, l, len, len1, m, n, o, out, ref1, ref2, ref3, ref4, ref5, row;
    out = [];
    for (i = k = 0, ref1 = token.header.length; 0 <= ref1 ? k < ref1 : k > ref1; i = 0 <= ref1 ? ++k : --k) {
      col = [token.header[i]];
      for (j = l = 0, ref2 = token.cells.length; 0 <= ref2 ? l < ref2 : l > ref2; j = 0 <= ref2 ? ++l : --l) {
        token.cells[j][i] = (token.cells[j][i] != null ? token.cells[j][i].trim() : '');
        col.push(token.cells[j][i]);
      }
      colWidth = longestStringInArray(col);
      token.header[i] = pad(token.header[i], colWidth);
      alignment = token.align[i];
      token.align[i] = ((function() {
        switch (alignment) {
          case null:
            return pad('', colWidth, '-');
          case 'left':
            return ':' + pad('', colWidth - 1, '-');
          case 'center':
            return ':' + pad('', colWidth - 2, '-') + ':';
          case 'right':
            return pad('', colWidth - 1, '-') + ':';
        }
      })());
      for (j = m = 0, ref3 = token.cells.length; 0 <= ref3 ? m < ref3 : m > ref3; j = 0 <= ref3 ? ++m : --m) {
        token.cells[j][i] = (alignment === 'right' ? pad(colWidth, token.cells[j][i]) : pad(token.cells[j][i], colWidth));
      }
    }
    if (token.header.length > 1) {
      out.push(token.header.join(' | ').trimRight());
      out.push(token.align.join(' | '));
      ref4 = token.cells;
      for (n = 0, len = ref4.length; n < len; n++) {
        row = ref4[n];
        out.push(row.join(' | ').trimRight());
      }
    } else {
      out.push('| ' + token.header[0].trimRight());
      out.push('| ' + token.align[0]);
      ref5 = token.cells;
      for (o = 0, len1 = ref5.length; o < len1; o++) {
        row = ref5[o];
        out.push('| ' + row[0].trimRight());
      }
    }
    out.push('');
    return out;
  };

  module.exports = function(dirtyMarkdown, options) {
    var ast, content, id, k, l, len, len1, line, link, links, optionalTitle, out, previousToken, ref1, ref2, ref3, token;
    if (options == null) {
      options = {};
    }
    if (options.ensureFirstHeaderIsH1 == null) {
      options.ensureFirstHeaderIsH1 = true;
    }
    out = [];
    content = fm(dirtyMarkdown);
    if (Object.keys(content.attributes).length !== 0) {
      out.push('---', yaml.safeDump(content.attributes).trim(), '---\n');
    }
    ast = marked.lexer(content.body);
    links = ast.links;
    previousToken = void 0;
    ast = ast.filter(function(token) {
      var ref1;
      return (ref1 = token.type) !== 'space' && ref1 !== 'list_end';
    });
    ast = preprocessAST(ast);
    ast = fixHeaders(ast, options.ensureFirstHeaderIsH1);
    for (k = 0, len = ast.length; k < len; k++) {
      token = ast[k];
      if (token.indent == null) {
        token.indent = '';
      }
      if (token.nesting == null) {
        token.nesting = [];
      }
      switch (token.type) {
        case 'heading':
          if ((previousToken != null) && previousToken.type !== 'heading') {
            out.push('');
          }
          out.push(stringRepeat('#', token.depth) + ' ' + token.text);
          break;
        case 'paragraph':
          if ((ref1 = previousToken != null ? previousToken.type : void 0) === 'paragraph' || ref1 === 'list_item' || ref1 === 'text') {
            out.push('');
          }
          out.push(token.indent + tidyInlineMarkdown(token).text.replace(/\n/g, ' '));
          break;
        case 'text':
        case 'list_item':
          if ((previousToken != null) && token.type === 'list_item' && (previousToken.nesting.length > token.nesting.length || (previousToken.type === 'paragraph' && ((ref2 = previousToken.nesting) != null ? ref2.length : void 0) >= token.nesting.length))) {
            out.push('');
          }
          out.push(token.indent + tidyInlineMarkdown(token).text);
          break;
        case 'code':
          if (token.lang == null) {
            token.lang = '';
          }
          token.text = delimitCode(token.lang + "\n" + token.text + "\n", '```');
          out.push('', indent(token.text, token.indent), '');
          break;
        case 'table':
          if (previousToken != null) {
            out.push('');
          }
          out.push.apply(out, formatTable(token));
          break;
        case 'hr':
          if (previousToken != null) {
            out.push('');
          }
          out.push(token.indent + stringRepeat('-', 80), '');
          break;
        case 'html':
          ref3 = token.text.split('\n');
          for (l = 0, len1 = ref3.length; l < len1; l++) {
            line = ref3[l];
            out.push(line);
          }
          break;
        default:
          throw new Error("Unknown Token: " + token.type);
      }
      previousToken = token;
    }
    if (Object.keys(links).length > 0) {
      out.push('');
    }
    for (id in links) {
      link = links[id];
      optionalTitle = link.title ? " \"" + link.title + "\"" : '';
      out.push("[" + id + "]: " + link.href + optionalTitle);
    }
    out.push('');
    out = out.filter(function(val, i, arr) {
      return !(val === '' && arr[i - 1] === '');
    });
    return out.join('\n');
  };

}).call(this);
